## üõ†Ô∏è Tecnolog√≠as Utilizadas

Nuestro stack tecnol√≥gico est√° cuidadosamente seleccionado para proporcionar un rendimiento √≥ptimo, escalabilidad y mantenibilidad:

- **Lenguajes:**
    <details>
    <summary>Java (versi√≥n 17) <img width="20" height="20" src="https://img.icons8.com/external-flaticons-flat-flat-icons/64/external-java-computer-programming-flaticons-flat-flat-icons.png" alt="external-java-computer-programming-flaticons-flat-flat-icons"/></summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
- **Herramientas:**
    <details>
    <summary>Spring Boot con Spring WebFlux <img width="20" height="20" src="https://img.icons8.com/color/48/spring-logo.png" alt="spring-logo"/></summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
    <details>
    <summary>Maven <img width="20" height="20" src="https://img.icons8.com/water-color/50/maven-ios.png" alt="maven-ios"/></summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
    <details>
    <summary>Gitlab <img width="20" height="20" src="https://img.icons8.com/color/48/gitlab.png" alt="gitlab"/> y GitHub <img width="20" height="20" src="https://img.icons8.com/ios-glyphs/30/github.png" alt="github"/> </summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
    <details>
    <summary>Lombook üå∂</summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
    <details>
    <summary>Postman <img width="20" height="20" src="https://img.icons8.com/dusk/64/postman-api.png" alt="postman-api"/> </summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
- **Base de datos:**
    <details>
    <summary>MongoDB (Atlas) <img width="30" height="30" src="https://img.icons8.com/color/48/mongo-db.png" alt="mongo-db"/></summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
- **Testing y Calidad:**
    <details>
    <summary>SonarCloud</summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
    <details>
    <summary>JUnit 5</summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>
    <details>
- **Por Implementar:**
    <details>
    <summary>Apache JMeter üìà</summary>
        La arquitectura hexagonal promueve una clara separaci√≥n entre la l√≥gica del negocio y la implementaci√≥n t√©cnica mediante el uso de puertos y adaptadores. Esto facilita el intercambio de componentes porque los adaptadores se            encargan de integrar tecnolog√≠as externas o servicios, mientras que los puertos definen las interfaces que deben implementar los adaptadores. De esta manera, es m√°s sencillo reemplazar o actualizar adaptadores sin afectar la           l√≥gica de negocio, mejorando as√≠ la mantenibilidad y extensibilidad del sistema.
    </details>


---
   
   ### Gesti√≥n de Cors (Cross-Origin Resource Sharing)
   
     Emplear `@CrossOrigin` en los controladores de Spring para controlar el acceso desde dominios espec√≠ficos, mejorando la seguridad y la interoperabilidad de la aplicaci√≥n.
   
   ```java
   @RestController
   @RequestMapping("/api/v1")
   @CrossOrigin(origins = "http://example.com")
   public class UserController {
   
      @GetMapping("/users")
       public List<User> getAllUsers() {
           // L√≥gica para obtener todos los usuarios
           return userService.getAllUsers();
       }
   
     @PostMapping("/users")
       public ResponseEntity<User> createUser(@RequestBody User user) {
           // L√≥gica para crear un nuevo usuario
           User createdUser = userService.createUser(user);
           return ResponseEntity.created(URI.create("/api/v1/users/" + createdUser.getId())).body(createdUser);
       }
   }
   ```

